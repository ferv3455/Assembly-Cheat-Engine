# 运行时内存修改器 说明文档

## 1. 开发环境

Visual Studio 2022 + MASM32 SDK Version 11.0，按照提供的方案配置编程环境、设置项目的链接器和汇编器。

## 2. 实现原理

### 主程序逻辑

主程序代码见 `winmain.asm`，在创建窗口后，利用事件循环和处理来进行状态间的转移，以此来实现完整的程序逻辑。其中涉及到的和内存修改相关的功能都实现在单独的模块中，借助 `memeditor.inc` 引入。

事件的处理包含在WinProc过程中，其中维护了一个有限状态自动机（状态为`state`），对于初始状态、选择进程后、准备开始扫描、进行扫描后的几种状态分别进行处理，涉及到界面组件状态的改变、实际功能的调用等。

### GUI界面

在创建主窗口之后，通过添加子窗口的方式，使用`api: CreateWindow`根据需求添加组件。在创建组件的过程中，需要查阅Win32中的窗口风格、窗口类型等常量，通过参数值的不同来区分组件的类型。

此外，在添加组件元素、修改内容时，还需要在查阅信息类型之后，使用`api: SendMessage`向窗口传递不同的信息。读取组件内容也需要使用特定的`api: GetDlgItemText`、`api: GetDlgItemInt`来处理。

### 选取进程

这部分的代码见 `process.asm` 文件。

要让用户选择程序来修改，首先就需要给用户提供所有可供修改内存的进程。由于 32 位程序中使用的 `EnumProcesses` 等 Windows API 只能列举出 32 位进程，因此这里支持的程序**仅限于 32 位**。该步骤思路如下：

1.  使用 `api: EnumProcesses` 将所有的进程 PID 存储在数组中。
2.  迭代读取进程的 PID，使用 `api: OpenProcess` 和 `api: EnumProcessModules` 打开并获取进程的依赖项和模块。由于 `api: OpenProcess` 也会在修改内存时使用，因此如果该操作打开失败，那么就不支持内存的修改。
3.  将支持的进程 PID 存储在数组中，在之后选择进程时使用。

### 目标地址搜索

这部分的代码见 `filter.asm` 文件。

需要实现内存修改功能，首先应能定位到相应的内存。因此，这部分的基本思路模仿了 [Cheat Engine](https://www.cheatengine.org/downloads.php) ，即：

1.  根据用户选择的进程 PID，通过 `api: OpenProcess` 打开相应进程并获得其句柄（首个参数设置为 `PROCESS_AL_ACCESS` 以便读取与更改）。之后进行第一遍搜索。
2.  从地址 `0` 开始，向 `7FFFFFFFH`，利用获得的句柄，使用 `api: VirtualQueryEx` 逐内存页面读取信息。
3.  若 `api: VirtualQueryEx` 读取的内存页面信息中页面状态为 `MEM_COMMIT` 才逐 `DWORD` 读取此页面中的内存地址。
4.  使用 `api: ReadProcessMemory` 逐 `DWORD` 读取内存地址中的值，并与用户输入的数值进行比较。
5.  若二者相同，则这个内存地址记录在 `lastsearch` 数组(`lastsearch DWORD 10240 DUP(?)`)中，并显示出来。
6.  第一遍搜索完成后，用户在游戏（想更改的进程对象）中使欲改动的值发生一定变化，并记录这个值。让用户输入记录的变化后的值，之后进行第二遍搜索。
7.  逐个读取 `lastsearch` 中每个单元存储的内存地址中的值，并与用户此次输入的值比较，若相同则输出其内存地址。

这样，通过若干次搜索，就基本可定位用户想更改的数值所在的内存地址，这样就能通过下一步的 `Edit` 更改它了。

### 内存修改

这部分的代码见 `memedit.asm` 文件。

内存修改的实现比较简单，在使用 `api: OpenProcess` 打开相应进程并获取句柄后，借助 `api: ReadProcessMemory` 和 `api: WriteProcessMemory` 即可完成读写操作。

## 3. 难点与创新点

### 难点

- 对 Windows 的 API 不熟悉，此前完全没有用过，这次使用的 `OpenProcess, EnumProcessModules, VirtualQueryEx, ReadProcessMemory` 等 API 都是临时参考了 [Win32 API 编程参考 - Win32 apps | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/win32/api/) 学习使用的。
- 在使用 API 时，尤其是执行处理打开进程、访问内存等可能不成功的操作时，需要充分考虑异常情况，设置过程的出口，防止出现意料之外的运行问题。
- 此前并不是很了解使用汇编语言编程，不熟悉汇编语言程序中出现的 bug，如过程的定义方式、多模块程序设计、指针变量的使用等，导致 debug 难度更高、花费的时间更长。
- 寄存器中的值会因为某些操作（如输入输出）而改变，因此最初未注意保存寄存器值时，出现了一些令人摸不着头脑的 bug。同时我们组的项目涉及到对内存的大量读取和检测，寄存器的值更新次数多、速度快，影响了找到问题所在，最后是通过加很多个断点并单步执行多个循环才发现问题。
- GUI 界面的上手和基本使用并不容易。由于没有现有的绘图库和组件库，我们需要参考提供的 WinApp 窗口程序，借助 Win32 API 从建立窗口开始，为每个按钮、文本框等组件创建各自子窗口，并设置正确的格式和位置。创建和布局 GUI 的所有控件就需要一定的工作量，且在使用 `CreateWindowEx` 等 API 创建不同组件时，或处理捕捉到的事件类型时，参数均需要一个个查询，比较耗时。

### 创新点

- 最初的内存搜索是暴力的全局搜索（`00000000H-7FFFFFFFH`），速度较慢，而之后使用了 `VirtualQueryEx` 这个 API，使用了上学期所学的操作系统的知识，以页表为单位跳过当前句柄没有访问权限的内存区域，节省了大量不必要的内存访问与查询，极大地加快了运行速度。
    ```nasm
    invoke      VirtualQueryEx, ebx, edi, ADDR mbi, SIZEOF mbi
    test        eax, eax
    jz          fail_RET
    mov         edx, maxAddr
    add         edx, mbi[12]
    mov         maxAddr, edx
    mov         eax, mbi[16]
    cmp         eax, MEM_COMMIT
    je          PIECE
    ```

## 4. 与中期相比的进展

中期提交时已经实现了内存修改的基本功能，包括进程选取、简单的地址扫描、内存修改等，并实现了简单的GUI界面，同时也提供了控制台版本的程序。

之后，我们主要对修改器的功能进行了扩展，完善了GUI界面，并解决了不少的bug。我们依次完成了更多数据类型的支持、搜索地址步长选择、搜索条件选择（如大于小于）、搜索范围选择等功能，并针对这些功能修改GUI界面。

## 5. 小组分工

- 顾洋丞：进程选取、内存修改和主程序事件逻辑
- 王麒杰：目标地址搜索和存储
- 王子扬：GUI 界面设计和组件布局
