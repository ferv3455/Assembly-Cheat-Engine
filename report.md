# 运行时内存修改器 说明文档

## 1. 开发环境

Visual Studio 2022 + MASM32 SDK Version 11.0，按照提供的方案配置编程环境、设置项目的链接器和汇编器。

## 2. 实现原理

### 主程序逻辑

主程序代码见 `winmain.asm`，在创建窗口后，利用事件循环和处理来进行状态间的转移，以此来实现完整的程序逻辑。其中涉及到的和内存修改相关的功能都实现在单独的模块中，借助 `memeditor.inc` 引入。

事件的处理包含在WinProc过程中，其中维护了一个有限状态自动机（状态为`state`），对于初始状态、选择进程后、准备开始扫描、进行扫描后的几种状态分别进行处理，涉及到界面组件状态的改变、实际功能的调用等。

### GUI界面

在创建主窗口之后，通过添加子窗口的方式，使用`api: CreateWindow`根据需求添加组件。在创建组件的过程中，需要查阅Win32中的窗口风格、窗口类型等常量，通过参数值的不同来区分组件的类型。

此外，在添加组件元素、修改内容时，还需要在查阅信息类型之后，使用`api: SendMessage`向窗口传递不同的信息。读取组件内容也需要使用特定的`api: GetDlgItemText`、`api: GetDlgItemInt`来处理。

### 选取进程

这部分的代码见 `process.asm` 文件。

要让用户选择程序来修改，首先就需要给用户提供所有可供修改内存的进程。由于 32 位程序中使用的 `EnumProcesses` 等 Windows API 只能列举出 32 位进程，因此这里支持的程序**仅限于 32 位**。该步骤思路如下：

1.  使用 `api: EnumProcesses` 将所有的进程 PID 存储在数组中。
2.  迭代读取进程的 PID，使用 `api: OpenProcess` 和 `api: EnumProcessModules` 打开并获取进程的依赖项和模块。由于 `api: OpenProcess` 也会在修改内存时使用，因此如果该操作打开失败，那么就不支持内存的修改。
3.  将支持的进程 PID 存储在数组中，在之后选择进程时使用。

### 目标地址搜索
#### 中期进度

这部分的代码见 `filter.asm` 文件。

需要实现内存修改功能，首先应能定位到相应的内存。因此，这部分的基本思路模仿了 [Cheat Engine](https://www.cheatengine.org/downloads.php) ，即：

1.  根据用户选择的进程 PID，通过 `api: OpenProcess` 打开相应进程并获得其句柄（首个参数设置为 `PROCESS_AL_ACCESS` 以便读取与更改）。之后进行第一遍搜索。
2.  从地址 `0` 开始，向 `7FFFFFFFH`，利用获得的句柄，使用 `api: VirtualQueryEx` 逐内存页面读取信息。
3.  若 `api: VirtualQueryEx` 读取的内存页面信息中页面状态为 `MEM_COMMIT` 才逐 `DWORD` 读取此页面中的内存地址。
4.  使用 `api: ReadProcessMemory` 逐 `DWORD` 读取内存地址中的值，并与用户输入的数值进行比较。
5.  若二者相同，则这个内存地址记录在 `lastsearch` 数组(`lastsearch DWORD 10240 DUP(?)`)中，并显示出来。
6.  第一遍搜索完成后，用户在游戏（想更改的进程对象）中使欲改动的值发生一定变化，并记录这个值。让用户输入记录的变化后的值，之后进行第二遍搜索。
7.  逐个读取 `lastsearch` 中每个单元存储的内存地址中的值，并与用户此次输入的值比较，若相同则输出其内存地址。

这样，通过若干次搜索，就基本可定位用户想更改的数值所在的内存地址，这样就能通过下一步的 `Edit` 更改它了。

#### 增加内容

`filter`部分的代码仍在 `filter.asm` 文件中。

在上述思路的基础上，增加(或修改)了以下内容：

1. 查询了32位机器内存中用户空间及内核空间的分配,一度将搜索地址的最大范围修改为用户空间`0H~BFFFFFFFH`。但之后发现实际上用户程序使用的空间集中于`0H~7FFFFFFFH`, `7FFFFFFFFH`以上的内存部分被`PCI Memory Address Range`所占据,因此将搜索地址的最大范围修改回了`0H~7FFFFFFFH`。
2. 增加了搜索选项:大于等于、大于、小于等于、小于、等于。这些选项分别对应`>=`、`>`、`<=`、`<`、`=`。用户可以选择其中一个选项，然后输入一个数值，之后进行搜索。搜索结果中的内存地址对应的值与用户输入的数值进行比较，若满足用户选择的条件，则输出该内存地址。
3. 增加了搜索选项:地址步长,现在可以按`BYTE`,`WORD`,`DWORD`的步长进行搜索。
4. 增加了搜索选项:目标值种类,现在可以按`BYTE`,`WORD`,`DWORD`,`FLOAT`,`DOUBLE`的种类进行搜索。
5. 在内存中搜索的范围不再为固定的值,而是可以由用户自己指定。如用户此前搜索到某个数值的地址为`0x12345678`,则在搜索与该数值联系紧密的地址时,可以将搜索范围设置为`0x12345678~0x12345678`,因为联系紧密的数值通常位于内存中地址相接近的区域,提供自定地址的搜索可以大大减少搜索的时间。

### 内存修改

这部分的代码见 `memedit.asm` 文件。

内存修改的实现比较简单，在使用 `api: OpenProcess` 打开相应进程并获取句柄后，借助 `api: ReadProcessMemory` 和 `api: WriteProcessMemory` 即可完成读写操作。

## 3. 难点与创新点

### 难点

- 对 Windows 的 API 不熟悉，此前完全没有用过，这次使用的 `OpenProcess, EnumProcessModules, VirtualQueryEx, ReadProcessMemory` 等 API 都是临时参考了 [Win32 API 编程参考 - Win32 apps | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/win32/api/) 学习使用的。
- 在使用 API 时，尤其是执行处理打开进程、访问内存等可能不成功的操作时，需要充分考虑异常情况，设置过程的出口，防止出现意料之外的运行问题。
- 此前并不是很了解使用汇编语言编程，不熟悉汇编语言程序中出现的 bug，如过程的定义方式、多模块程序设计、指针变量的使用等，导致 debug 难度更高、花费的时间更长。
- 寄存器中的值会因为某些操作（如输入输出）而改变，因此最初未注意保存寄存器值时，出现了一些令人摸不着头脑的 bug。同时我们组的项目涉及到对内存的大量读取和检测，寄存器的值更新次数多、速度快，影响了找到问题所在，最后是通过加很多个断点并单步执行多个循环才发现问题。
- GUI 界面的上手和基本使用并不容易。由于没有现有的绘图库和组件库，我们需要参考提供的 WinApp 窗口程序，借助 Win32 API 从建立窗口开始，为每个按钮、文本框等组件创建各自子窗口，并设置正确的格式和位置。创建和布局 GUI 的所有控件就需要一定的工作量，且在使用 `CreateWindowEx` 等 API 创建不同组件时，或处理捕捉到的事件类型时，参数均需要一个个查询，比较耗时。
- 对宏编译的条件掌握不够充分,原本搜索选项想采用宏的条件编译伪代码(`IF`&`ENDIF`)实现以节省代码,但是由于`IF`伪代码之后`expression`只能使用立即数进行`EQ`比较,而不能传入变量,导致无法利用宏完成,最后只能采用`.IF`&`.ENDIF`伪代码的形式实现。

### 创新点

- 最初的内存搜索是暴力的全局搜索（`00000000H-7FFFFFFFH`），速度较慢，而之后使用了 `VirtualQueryEx` 这个 API，使用了上学期所学的操作系统的知识，以页表为单位跳过当前句柄没有访问权限的内存区域，节省了大量不必要的内存访问与查询，极大地加快了运行速度。
    ```nasm
    invoke      VirtualQueryEx, ebx, edi, ADDR mbi, SIZEOF mbi
    test        eax, eax
    jz          fail_RET
    mov         edx, maxAddr
    add         edx, mbi[12]
    mov         maxAddr, edx
    mov         eax, mbi[16]
    cmp         eax, MEM_COMMIT
    je          PIECE
    ```
    
- 加入了丰富多样的搜索选项,包括搜索步长、搜索地址、被搜索数类型、搜索判断条件等,拓展了可用性。

<img src="\reportImgs\choosing.jpg" alt="choosing" style="zoom:50%;" />

- 对工程文件进行了分模块管理,使得代码更加清晰,易于维护:

<img src="\reportImgs\fileStructure.jpg" alt="fileStructure" style="zoom:50%;" />

## 4. 与中期相比的进展

中期提交时已经实现了内存修改的基本功能，包括进程选取、简单的地址扫描、内存修改等，并实现了简单的GUI界面，同时也提供了控制台版本的程序。

之后，我们主要对修改器的功能进行了扩展，完善了GUI界面，并解决了不少的bug。我们依次完成了更多数据类型的支持、搜索地址步长选择、搜索条件选择（如大于小于）、搜索范围选择等功能，并针对这些功能修改GUI界面。

## 5. 小组分工

- 顾洋丞：进程选取、内存修改和主程序事件逻辑
- 王麒杰：目标地址搜索和存储
- 王子扬：GUI 界面设计和组件布局
